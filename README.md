Keras 是 TensorFlow 系统的一部分
最受欢迎的两个选项是 TensorFlow 和 PyTorch

另一种选择方法是考虑
你想从哪个项目开始，然后搜索包含接近你目标的实现的 GitHub 存储库。然后，你可以使用他们正在使用的任
何库，并根据自己的目的修改它们的代码

因为一旦您了解一个深度学习库，那么其他任何一个库都不会太难

在本章中，我们将从简单网络开始，将其转变为深度网络，然后继续进入深度卷积网络和循环网络

使用像 Keras 这样的库让我们能够从深度学习思想的角度进行抽象思
考，而不会陷入其实现机制的泥潭。

Keras 文档特别以三种方式使用模型。首先，它指的是深度学习系统的架构。其次，
它描述了该架构与它在训练过程中学习到的权重的组合。第三，它可以指我们用来构
建系统的一组库调用，也称为 API（应用程序接口）

本章中我们将使用 Python 3.7.6  在本章中，我们使用2020 年 6 月发布的 Keras 版本 2.4.0
Keras 2.4.0、TensorFlow 2.4.1、NumPy1.19.2、matplotlib 3.4.1、scikit-learn 0.24.2、scikit-image 0.18.1 和 SciPy 1.6.3。

在编写程序时，我们通常会一次显示一小段代码。我们的想法是，通过组合这些代码
段（通常只需逐个输入代码段）来构建完整的程序。通过以小段的形式显示代码，可
以更轻松地阅读和讨论。

一种更简单的方法是找到触发问题的调用，然后暂时尽可能简化它，直到问题消
失。如果失败了，我们可以用我们其他项目中的代码片段，甚至是在线示例来替换
该调用。然后我们可以一步一步地将工作代码转换为我们自己的代码，这样我们就
可以发现到底是哪个步骤导致它失败。

使用 Keras 时，调试可能是一个挑战，因为错误往往难以捉摸。Keras 在大多数情况
下假设我们知道我们在做什么，并且它不会对我们的代码进行大量的错误检查

实上，
它是特意设计为与 scikit-learn 一起使用的，我们将在本章中自由使用这两个库。
借助 Keras，只需构建一堆参数化层，即可轻松创建深度学习网络。这种自由组合
既是好事也是坏事。

我们可以使用 Keras 轻松组装各种深度学习网络。但如果我们想要一个有意
义的网络，即它可以从示例中学习并做出正确的预测，我们需要谨慎选择我们的层
及其参数。每一层都必须在紧接其前后层的局部上下文中有意义，以及在网络中所
有其他层的更大上下文中有意义。

“数组”是一维列表，但请记住，在 NumPy 中，该词指的是可能具有多个维度的
张量。

在机
器学习中，网格和块必须是完整的。也就是说，不能有任何突出的部分，也不能有
洞。每一面都是平的，每个单元都是填满的。

要安装最新版本的 Keras，只需像安装系统上任何其他 Python 库一样安装
TensorFlow。Keras 将随即安装

我们通常在上面提到的 Keras 配置文件中提供此信息。在此文本文件中，我们通过
将名为“image_data_format”的参数设置为字符串来确定如何组织数据
‘channels_first’或 ‘channels_last’
当我们将Keras导入我们的Python代码时，Keras会读取这个配置文件

档将识别给定例程可用的选项，但可能不会描述这些选项的含义、每个选项的优缺
点，也不会描述我们应该使用什么标准来选择一个选项。

我们将一步一步地缓慢而谨慎地完成 MNIST 数据的剩余预处理。我们将使用 Keras
和 scikit-learn 中的工具。这既是为了仔细演示我们正在做的事情，也是为了展示我们
在考虑预处理时所经历的思维方式。
我们的目标不仅仅是预处理 MNIST 数据，而是展示该过程的流程，以便我们
将来可以将其应用到新的数据库

将 12 个项目的排列更改为图 B2-8 中的任意形状，并重复执行此操作，但
请记住，此操作只会改变计算机引用信息的方式。我们永远不会改变数据本身。换
句话说，当我们告诉计算机将数据重塑为其他形状时，它不会移动数据。重塑只是
告诉计算机我们将如何命名元素：我们将使用多少个维度，以及每个维度可以采用
什么值。它只是保存这些数字，然后在我们实际读取或写入数据时使用它们。因
此，重塑 12 个元素的列表并不比重塑 1200 万个元素的列表更快。计算机只会记住
我们有多少个维度，以及每个维度有多大

如果我们将张量原始形状的
所有维度相乘（此处为 3 乘以 4=12），我们得到的值必须与将新形状的所有维度相乘
（此处为 2 乘以 6=12）得到的值相同。
demoData = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
newData = demoData.reshape((6, 2))
print(newData)
[[ 1 2]
[ 3 4]
[ 5 6]
[ 7 8]
[ 9 10]
[11 12]]

只要这些伪影
不是太多，它们就能让我们的系统更强大。如果我们的网络能够正确识别这些图
像，尽管它们存在缺陷，那么它就具有了强大的品质，如果没有这些令人紧张的例
子，它就不会拥有这种品质。

用简写 X 表示样本，y 表示标签

让我们将每幅图像的原始高度和宽度存储在一个
变量中。我们还将它们相乘并将其保存为每幅图像的总像素数。

图像匹配。
由于 MNIST 数据非常知名，我们可以就此停止，但对于不太熟悉的数据集，我们可
能需要在整个数据中进行至少几次这样的抽查，以确保两个列表保持同步

要使用这些数据进行 Keras 训练，我们需要将训练和测试样本数据转换为规范化的浮
点数，并将标签转换为独热编码

使用 scikit-learn 的 train_ test_split() 函
数手动将其拆分为训练集和测试集

当学习一个新的库时，大量的小实验可以帮助我们从一开始就编写出好的代码

规范化仅针对特征，而不针对标签。标签需要指代从 0 到 9 的 10 个不同类
别，我们不想更改这些值

准备数据的另一个重要步骤是规范化。在不同情况下，这可能意味着略有不同，但
它始终意味着更改数据本身，而不是简单地重塑数据。
我们将在本章中构建用于对 MNIST 数据进行分类的网络，该网络将在开始时使用
卷积层，这些网络最适合已标准化的数据，以便每个特征都已缩放以适应 0 到 1 的
范围。


gai 65 le






